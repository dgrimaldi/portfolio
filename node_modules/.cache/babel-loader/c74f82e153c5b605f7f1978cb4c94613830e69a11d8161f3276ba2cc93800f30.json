{"ast":null,"code":"\"use client\";\n\nimport _defineProperty from \"/home/dgrimaldi/Documents/portfolio/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/home/dgrimaldi/Documents/portfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport React from 'react';\nimport classNames from 'classnames';\nimport ResizeObserver from 'rc-resize-observer';\nimport omit from \"rc-util/es/omit\";\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { ConfigContext } from '../config-provider';\nimport useStyle from './style';\nimport { getFixedBottom, getFixedTop, getTargetRect } from './utils';\nvar TRIGGER_EVENTS = ['resize', 'scroll', 'touchstart', 'touchmove', 'touchend', 'pageshow', 'load'];\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nvar AffixStatus;\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {}));\nvar InternalAffix = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  var _classNames;\n  var _a;\n  var style = props.style,\n    offsetTop = props.offsetTop,\n    offsetBottom = props.offsetBottom,\n    affixPrefixCls = props.affixPrefixCls,\n    rootClassName = props.rootClassName,\n    children = props.children,\n    target = props.target,\n    onChange = props.onChange;\n  var _React$useState = React.useState(false),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    lastAffix = _React$useState2[0],\n    setLastAffix = _React$useState2[1];\n  var _React$useState3 = React.useState(),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    affixStyle = _React$useState4[0],\n    setAffixStyle = _React$useState4[1];\n  var _React$useState5 = React.useState(),\n    _React$useState6 = _slicedToArray(_React$useState5, 2),\n    placeholderStyle = _React$useState6[0],\n    setPlaceholderStyle = _React$useState6[1];\n  var status = React.useRef(AffixStatus.None);\n  var prevTarget = React.useRef(null);\n  var prevListener = React.useRef();\n  var placeholderNodeRef = React.useRef(null);\n  var fixedNodeRef = React.useRef(null);\n  var timer = React.useRef(null);\n  var _React$useContext = React.useContext(ConfigContext),\n    getTargetContainer = _React$useContext.getTargetContainer;\n  var targetFunc = (_a = target !== null && target !== void 0 ? target : getTargetContainer) !== null && _a !== void 0 ? _a : getDefaultTarget;\n  var internalOffsetTop = offsetBottom === undefined && offsetTop === undefined ? 0 : offsetTop;\n  // =================== Measure ===================\n  var measure = function measure() {\n    if (status.current !== AffixStatus.Prepare || !fixedNodeRef.current || !placeholderNodeRef.current || !targetFunc) {\n      return;\n    }\n    var targetNode = targetFunc();\n    if (targetNode) {\n      var newState = {\n        status: AffixStatus.None\n      };\n      var placeholderRect = getTargetRect(placeholderNodeRef.current);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      var targetRect = getTargetRect(targetNode);\n      var fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);\n      var fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n      }\n      newState.lastAffix = !!newState.affixStyle;\n      if (lastAffix !== newState.lastAffix) {\n        onChange === null || onChange === void 0 ? void 0 : onChange(newState.lastAffix);\n      }\n      status.current = newState.status;\n      setAffixStyle(newState.affixStyle);\n      setPlaceholderStyle(newState.placeholderStyle);\n      setLastAffix(newState.lastAffix);\n    }\n  };\n  var prepareMeasure = function prepareMeasure() {\n    var _a;\n    status.current = AffixStatus.Prepare;\n    measure();\n    if (process.env.NODE_ENV === 'test') {\n      (_a = props === null || props === void 0 ? void 0 : props.onTestUpdatePosition) === null || _a === void 0 ? void 0 : _a.call(props);\n    }\n  };\n  var updatePosition = throttleByAnimationFrame(function () {\n    prepareMeasure();\n  });\n  var lazyUpdatePosition = throttleByAnimationFrame(function () {\n    // Check position change before measure to make Safari smooth\n    if (targetFunc && affixStyle) {\n      var targetNode = targetFunc();\n      if (targetNode && placeholderNodeRef.current) {\n        var targetRect = getTargetRect(targetNode);\n        var placeholderRect = getTargetRect(placeholderNodeRef.current);\n        var fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);\n        var fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n        if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n          return;\n        }\n      }\n    }\n    // Directly call prepare measure since it's already throttled.\n    prepareMeasure();\n  });\n  var addListeners = function addListeners() {\n    var listenerTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n    TRIGGER_EVENTS.forEach(function (eventName) {\n      var _a;\n      if (prevListener.current) {\n        (_a = prevTarget.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, prevListener.current);\n      }\n      listenerTarget === null || listenerTarget === void 0 ? void 0 : listenerTarget.addEventListener(eventName, lazyUpdatePosition);\n    });\n    prevTarget.current = listenerTarget;\n    prevListener.current = lazyUpdatePosition;\n  };\n  var removeListeners = function removeListeners() {\n    if (timer.current) {\n      clearTimeout(timer.current);\n      timer.current = null;\n    }\n    var newTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n    TRIGGER_EVENTS.forEach(function (eventName) {\n      var _a;\n      newTarget === null || newTarget === void 0 ? void 0 : newTarget.removeEventListener(eventName, lazyUpdatePosition);\n      if (prevListener.current) {\n        (_a = prevTarget.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, prevListener.current);\n      }\n    });\n    updatePosition.cancel();\n    lazyUpdatePosition.cancel();\n  };\n  React.useImperativeHandle(ref, function () {\n    return {\n      updatePosition: updatePosition\n    };\n  });\n  // mount & unmount\n  React.useEffect(function () {\n    // [Legacy] Wait for parent component ref has its value.\n    // We should use target as directly element instead of function which makes element check hard.\n    timer.current = setTimeout(addListeners);\n    return function () {\n      return removeListeners();\n    };\n  }, []);\n  React.useEffect(function () {\n    addListeners();\n  }, [target, affixStyle]);\n  React.useEffect(function () {\n    updatePosition();\n  }, [target, offsetTop, offsetBottom]);\n  var className = classNames((_classNames = {}, _defineProperty(_classNames, affixPrefixCls, affixStyle), _defineProperty(_classNames, rootClassName, affixStyle && rootClassName), _classNames));\n  var otherProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'affixPrefixCls', 'rootClassName']);\n  if (process.env.NODE_ENV === 'test') {\n    otherProps = omit(otherProps, ['onTestUpdatePosition']);\n  }\n  return /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: updatePosition\n  }, /*#__PURE__*/React.createElement(\"div\", Object.assign({\n    style: style,\n    ref: placeholderNodeRef\n  }, otherProps), affixStyle && /*#__PURE__*/React.createElement(\"div\", {\n    style: placeholderStyle,\n    \"aria-hidden\": \"true\"\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: className,\n    ref: fixedNodeRef,\n    style: affixStyle\n  }, /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: updatePosition\n  }, children))));\n});\nvar Affix = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  var customizePrefixCls = props.prefixCls,\n    rootClassName = props.rootClassName;\n  var _React$useContext2 = React.useContext(ConfigContext),\n    getPrefixCls = _React$useContext2.getPrefixCls;\n  var affixPrefixCls = getPrefixCls('affix', customizePrefixCls);\n  var _useStyle = useStyle(affixPrefixCls),\n    _useStyle2 = _slicedToArray(_useStyle, 2),\n    wrapSSR = _useStyle2[0],\n    hashId = _useStyle2[1];\n  var AffixProps = Object.assign(Object.assign({}, props), {\n    affixPrefixCls: affixPrefixCls,\n    rootClassName: classNames(rootClassName, hashId)\n  });\n  return wrapSSR( /*#__PURE__*/React.createElement(InternalAffix, Object.assign({}, AffixProps, {\n    ref: ref\n  })));\n});\nif (process.env.NODE_ENV !== 'production') {\n  Affix.displayName = 'Affix';\n}\nexport default Affix;","map":{"version":3,"names":["_defineProperty","_slicedToArray","React","classNames","ResizeObserver","omit","throttleByAnimationFrame","ConfigContext","useStyle","getFixedBottom","getFixedTop","getTargetRect","TRIGGER_EVENTS","getDefaultTarget","window","AffixStatus","InternalAffix","forwardRef","props","ref","_classNames","_a","style","offsetTop","offsetBottom","affixPrefixCls","rootClassName","children","target","onChange","_React$useState","useState","_React$useState2","lastAffix","setLastAffix","_React$useState3","_React$useState4","affixStyle","setAffixStyle","_React$useState5","_React$useState6","placeholderStyle","setPlaceholderStyle","status","useRef","None","prevTarget","prevListener","placeholderNodeRef","fixedNodeRef","timer","_React$useContext","useContext","getTargetContainer","targetFunc","internalOffsetTop","undefined","measure","current","Prepare","targetNode","newState","placeholderRect","top","left","width","height","targetRect","fixedTop","fixedBottom","position","bottom","prepareMeasure","process","env","NODE_ENV","onTestUpdatePosition","call","updatePosition","lazyUpdatePosition","addListeners","listenerTarget","forEach","eventName","removeEventListener","addEventListener","removeListeners","clearTimeout","newTarget","cancel","useImperativeHandle","useEffect","setTimeout","className","otherProps","createElement","onResize","Object","assign","Affix","customizePrefixCls","prefixCls","_React$useContext2","getPrefixCls","_useStyle","_useStyle2","wrapSSR","hashId","AffixProps","displayName"],"sources":["/home/dgrimaldi/Documents/portfolio/node_modules/antd/es/affix/index.js"],"sourcesContent":["\"use client\";\n\nimport React from 'react';\nimport classNames from 'classnames';\nimport ResizeObserver from 'rc-resize-observer';\nimport omit from \"rc-util/es/omit\";\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { ConfigContext } from '../config-provider';\nimport useStyle from './style';\nimport { getFixedBottom, getFixedTop, getTargetRect } from './utils';\nconst TRIGGER_EVENTS = ['resize', 'scroll', 'touchstart', 'touchmove', 'touchend', 'pageshow', 'load'];\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nvar AffixStatus;\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {}));\nconst InternalAffix = /*#__PURE__*/React.forwardRef((props, ref) => {\n  var _a;\n  const {\n    style,\n    offsetTop,\n    offsetBottom,\n    affixPrefixCls,\n    rootClassName,\n    children,\n    target,\n    onChange\n  } = props;\n  const [lastAffix, setLastAffix] = React.useState(false);\n  const [affixStyle, setAffixStyle] = React.useState();\n  const [placeholderStyle, setPlaceholderStyle] = React.useState();\n  const status = React.useRef(AffixStatus.None);\n  const prevTarget = React.useRef(null);\n  const prevListener = React.useRef();\n  const placeholderNodeRef = React.useRef(null);\n  const fixedNodeRef = React.useRef(null);\n  const timer = React.useRef(null);\n  const {\n    getTargetContainer\n  } = React.useContext(ConfigContext);\n  const targetFunc = (_a = target !== null && target !== void 0 ? target : getTargetContainer) !== null && _a !== void 0 ? _a : getDefaultTarget;\n  const internalOffsetTop = offsetBottom === undefined && offsetTop === undefined ? 0 : offsetTop;\n  // =================== Measure ===================\n  const measure = () => {\n    if (status.current !== AffixStatus.Prepare || !fixedNodeRef.current || !placeholderNodeRef.current || !targetFunc) {\n      return;\n    }\n    const targetNode = targetFunc();\n    if (targetNode) {\n      const newState = {\n        status: AffixStatus.None\n      };\n      const placeholderRect = getTargetRect(placeholderNodeRef.current);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      const targetRect = getTargetRect(targetNode);\n      const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);\n      const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n      }\n      newState.lastAffix = !!newState.affixStyle;\n      if (lastAffix !== newState.lastAffix) {\n        onChange === null || onChange === void 0 ? void 0 : onChange(newState.lastAffix);\n      }\n      status.current = newState.status;\n      setAffixStyle(newState.affixStyle);\n      setPlaceholderStyle(newState.placeholderStyle);\n      setLastAffix(newState.lastAffix);\n    }\n  };\n  const prepareMeasure = () => {\n    var _a;\n    status.current = AffixStatus.Prepare;\n    measure();\n    if (process.env.NODE_ENV === 'test') {\n      (_a = props === null || props === void 0 ? void 0 : props.onTestUpdatePosition) === null || _a === void 0 ? void 0 : _a.call(props);\n    }\n  };\n  const updatePosition = throttleByAnimationFrame(() => {\n    prepareMeasure();\n  });\n  const lazyUpdatePosition = throttleByAnimationFrame(() => {\n    // Check position change before measure to make Safari smooth\n    if (targetFunc && affixStyle) {\n      const targetNode = targetFunc();\n      if (targetNode && placeholderNodeRef.current) {\n        const targetRect = getTargetRect(targetNode);\n        const placeholderRect = getTargetRect(placeholderNodeRef.current);\n        const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);\n        const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n        if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n          return;\n        }\n      }\n    }\n    // Directly call prepare measure since it's already throttled.\n    prepareMeasure();\n  });\n  const addListeners = () => {\n    const listenerTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n    TRIGGER_EVENTS.forEach(eventName => {\n      var _a;\n      if (prevListener.current) {\n        (_a = prevTarget.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, prevListener.current);\n      }\n      listenerTarget === null || listenerTarget === void 0 ? void 0 : listenerTarget.addEventListener(eventName, lazyUpdatePosition);\n    });\n    prevTarget.current = listenerTarget;\n    prevListener.current = lazyUpdatePosition;\n  };\n  const removeListeners = () => {\n    if (timer.current) {\n      clearTimeout(timer.current);\n      timer.current = null;\n    }\n    const newTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n    TRIGGER_EVENTS.forEach(eventName => {\n      var _a;\n      newTarget === null || newTarget === void 0 ? void 0 : newTarget.removeEventListener(eventName, lazyUpdatePosition);\n      if (prevListener.current) {\n        (_a = prevTarget.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, prevListener.current);\n      }\n    });\n    updatePosition.cancel();\n    lazyUpdatePosition.cancel();\n  };\n  React.useImperativeHandle(ref, () => ({\n    updatePosition\n  }));\n  // mount & unmount\n  React.useEffect(() => {\n    // [Legacy] Wait for parent component ref has its value.\n    // We should use target as directly element instead of function which makes element check hard.\n    timer.current = setTimeout(addListeners);\n    return () => removeListeners();\n  }, []);\n  React.useEffect(() => {\n    addListeners();\n  }, [target, affixStyle]);\n  React.useEffect(() => {\n    updatePosition();\n  }, [target, offsetTop, offsetBottom]);\n  const className = classNames({\n    [affixPrefixCls]: affixStyle,\n    [rootClassName]: affixStyle && rootClassName\n  });\n  let otherProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'affixPrefixCls', 'rootClassName']);\n  if (process.env.NODE_ENV === 'test') {\n    otherProps = omit(otherProps, ['onTestUpdatePosition']);\n  }\n  return /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: updatePosition\n  }, /*#__PURE__*/React.createElement(\"div\", Object.assign({\n    style: style,\n    ref: placeholderNodeRef\n  }, otherProps), affixStyle && /*#__PURE__*/React.createElement(\"div\", {\n    style: placeholderStyle,\n    \"aria-hidden\": \"true\"\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: className,\n    ref: fixedNodeRef,\n    style: affixStyle\n  }, /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: updatePosition\n  }, children))));\n});\nconst Affix = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const {\n    prefixCls: customizePrefixCls,\n    rootClassName\n  } = props;\n  const {\n    getPrefixCls\n  } = React.useContext(ConfigContext);\n  const affixPrefixCls = getPrefixCls('affix', customizePrefixCls);\n  const [wrapSSR, hashId] = useStyle(affixPrefixCls);\n  const AffixProps = Object.assign(Object.assign({}, props), {\n    affixPrefixCls,\n    rootClassName: classNames(rootClassName, hashId)\n  });\n  return wrapSSR( /*#__PURE__*/React.createElement(InternalAffix, Object.assign({}, AffixProps, {\n    ref: ref\n  })));\n});\nif (process.env.NODE_ENV !== 'production') {\n  Affix.displayName = 'Affix';\n}\nexport default Affix;"],"mappings":"AAAA,YAAY;;AAAC,OAAAA,eAAA;AAAA,OAAAC,cAAA;AAEb,OAAOC,KAAK,MAAM,OAAO;AACzB,OAAOC,UAAU,MAAM,YAAY;AACnC,OAAOC,cAAc,MAAM,oBAAoB;AAC/C,OAAOC,IAAI,MAAM,iBAAiB;AAClC,OAAOC,wBAAwB,MAAM,mCAAmC;AACxE,SAASC,aAAa,QAAQ,oBAAoB;AAClD,OAAOC,QAAQ,MAAM,SAAS;AAC9B,SAASC,cAAc,EAAEC,WAAW,EAAEC,aAAa,QAAQ,SAAS;AACpE,IAAMC,cAAc,GAAG,CAAC,QAAQ,EAAE,QAAQ,EAAE,YAAY,EAAE,WAAW,EAAE,UAAU,EAAE,UAAU,EAAE,MAAM,CAAC;AACtG,SAASC,gBAAgBA,CAAA,EAAG;EAC1B,OAAO,OAAOC,MAAM,KAAK,WAAW,GAAGA,MAAM,GAAG,IAAI;AACtD;AACA,IAAIC,WAAW;AACf,CAAC,UAAUA,WAAW,EAAE;EACtBA,WAAW,CAACA,WAAW,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EAC7CA,WAAW,CAACA,WAAW,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;AACrD,CAAC,EAAEA,WAAW,KAAKA,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC;AACrC,IAAMC,aAAa,GAAG,aAAad,KAAK,CAACe,UAAU,CAAC,UAACC,KAAK,EAAEC,GAAG,EAAK;EAAA,IAAAC,WAAA;EAClE,IAAIC,EAAE;EACN,IACEC,KAAK,GAQHJ,KAAK,CARPI,KAAK;IACLC,SAAS,GAOPL,KAAK,CAPPK,SAAS;IACTC,YAAY,GAMVN,KAAK,CANPM,YAAY;IACZC,cAAc,GAKZP,KAAK,CALPO,cAAc;IACdC,aAAa,GAIXR,KAAK,CAJPQ,aAAa;IACbC,QAAQ,GAGNT,KAAK,CAHPS,QAAQ;IACRC,MAAM,GAEJV,KAAK,CAFPU,MAAM;IACNC,QAAQ,GACNX,KAAK,CADPW,QAAQ;EAEV,IAAAC,eAAA,GAAkC5B,KAAK,CAAC6B,QAAQ,CAAC,KAAK,CAAC;IAAAC,gBAAA,GAAA/B,cAAA,CAAA6B,eAAA;IAAhDG,SAAS,GAAAD,gBAAA;IAAEE,YAAY,GAAAF,gBAAA;EAC9B,IAAAG,gBAAA,GAAoCjC,KAAK,CAAC6B,QAAQ,CAAC,CAAC;IAAAK,gBAAA,GAAAnC,cAAA,CAAAkC,gBAAA;IAA7CE,UAAU,GAAAD,gBAAA;IAAEE,aAAa,GAAAF,gBAAA;EAChC,IAAAG,gBAAA,GAAgDrC,KAAK,CAAC6B,QAAQ,CAAC,CAAC;IAAAS,gBAAA,GAAAvC,cAAA,CAAAsC,gBAAA;IAAzDE,gBAAgB,GAAAD,gBAAA;IAAEE,mBAAmB,GAAAF,gBAAA;EAC5C,IAAMG,MAAM,GAAGzC,KAAK,CAAC0C,MAAM,CAAC7B,WAAW,CAAC8B,IAAI,CAAC;EAC7C,IAAMC,UAAU,GAAG5C,KAAK,CAAC0C,MAAM,CAAC,IAAI,CAAC;EACrC,IAAMG,YAAY,GAAG7C,KAAK,CAAC0C,MAAM,CAAC,CAAC;EACnC,IAAMI,kBAAkB,GAAG9C,KAAK,CAAC0C,MAAM,CAAC,IAAI,CAAC;EAC7C,IAAMK,YAAY,GAAG/C,KAAK,CAAC0C,MAAM,CAAC,IAAI,CAAC;EACvC,IAAMM,KAAK,GAAGhD,KAAK,CAAC0C,MAAM,CAAC,IAAI,CAAC;EAChC,IAAAO,iBAAA,GAEIjD,KAAK,CAACkD,UAAU,CAAC7C,aAAa,CAAC;IADjC8C,kBAAkB,GAAAF,iBAAA,CAAlBE,kBAAkB;EAEpB,IAAMC,UAAU,GAAG,CAACjC,EAAE,GAAGO,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAGA,MAAM,GAAGyB,kBAAkB,MAAM,IAAI,IAAIhC,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAGR,gBAAgB;EAC9I,IAAM0C,iBAAiB,GAAG/B,YAAY,KAAKgC,SAAS,IAAIjC,SAAS,KAAKiC,SAAS,GAAG,CAAC,GAAGjC,SAAS;EAC/F;EACA,IAAMkC,OAAO,GAAG,SAAVA,OAAOA,CAAA,EAAS;IACpB,IAAId,MAAM,CAACe,OAAO,KAAK3C,WAAW,CAAC4C,OAAO,IAAI,CAACV,YAAY,CAACS,OAAO,IAAI,CAACV,kBAAkB,CAACU,OAAO,IAAI,CAACJ,UAAU,EAAE;MACjH;IACF;IACA,IAAMM,UAAU,GAAGN,UAAU,CAAC,CAAC;IAC/B,IAAIM,UAAU,EAAE;MACd,IAAMC,QAAQ,GAAG;QACflB,MAAM,EAAE5B,WAAW,CAAC8B;MACtB,CAAC;MACD,IAAMiB,eAAe,GAAGnD,aAAa,CAACqC,kBAAkB,CAACU,OAAO,CAAC;MACjE,IAAII,eAAe,CAACC,GAAG,KAAK,CAAC,IAAID,eAAe,CAACE,IAAI,KAAK,CAAC,IAAIF,eAAe,CAACG,KAAK,KAAK,CAAC,IAAIH,eAAe,CAACI,MAAM,KAAK,CAAC,EAAE;QAC1H;MACF;MACA,IAAMC,UAAU,GAAGxD,aAAa,CAACiD,UAAU,CAAC;MAC5C,IAAMQ,QAAQ,GAAG1D,WAAW,CAACoD,eAAe,EAAEK,UAAU,EAAEZ,iBAAiB,CAAC;MAC5E,IAAMc,WAAW,GAAG5D,cAAc,CAACqD,eAAe,EAAEK,UAAU,EAAE3C,YAAY,CAAC;MAC7E,IAAI4C,QAAQ,KAAKZ,SAAS,EAAE;QAC1BK,QAAQ,CAACxB,UAAU,GAAG;UACpBiC,QAAQ,EAAE,OAAO;UACjBP,GAAG,EAAEK,QAAQ;UACbH,KAAK,EAAEH,eAAe,CAACG,KAAK;UAC5BC,MAAM,EAAEJ,eAAe,CAACI;QAC1B,CAAC;QACDL,QAAQ,CAACpB,gBAAgB,GAAG;UAC1BwB,KAAK,EAAEH,eAAe,CAACG,KAAK;UAC5BC,MAAM,EAAEJ,eAAe,CAACI;QAC1B,CAAC;MACH,CAAC,MAAM,IAAIG,WAAW,KAAKb,SAAS,EAAE;QACpCK,QAAQ,CAACxB,UAAU,GAAG;UACpBiC,QAAQ,EAAE,OAAO;UACjBC,MAAM,EAAEF,WAAW;UACnBJ,KAAK,EAAEH,eAAe,CAACG,KAAK;UAC5BC,MAAM,EAAEJ,eAAe,CAACI;QAC1B,CAAC;QACDL,QAAQ,CAACpB,gBAAgB,GAAG;UAC1BwB,KAAK,EAAEH,eAAe,CAACG,KAAK;UAC5BC,MAAM,EAAEJ,eAAe,CAACI;QAC1B,CAAC;MACH;MACAL,QAAQ,CAAC5B,SAAS,GAAG,CAAC,CAAC4B,QAAQ,CAACxB,UAAU;MAC1C,IAAIJ,SAAS,KAAK4B,QAAQ,CAAC5B,SAAS,EAAE;QACpCJ,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACgC,QAAQ,CAAC5B,SAAS,CAAC;MAClF;MACAU,MAAM,CAACe,OAAO,GAAGG,QAAQ,CAAClB,MAAM;MAChCL,aAAa,CAACuB,QAAQ,CAACxB,UAAU,CAAC;MAClCK,mBAAmB,CAACmB,QAAQ,CAACpB,gBAAgB,CAAC;MAC9CP,YAAY,CAAC2B,QAAQ,CAAC5B,SAAS,CAAC;IAClC;EACF,CAAC;EACD,IAAMuC,cAAc,GAAG,SAAjBA,cAAcA,CAAA,EAAS;IAC3B,IAAInD,EAAE;IACNsB,MAAM,CAACe,OAAO,GAAG3C,WAAW,CAAC4C,OAAO;IACpCF,OAAO,CAAC,CAAC;IACT,IAAIgB,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,MAAM,EAAE;MACnC,CAACtD,EAAE,GAAGH,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAAC0D,oBAAoB,MAAM,IAAI,IAAIvD,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACwD,IAAI,CAAC3D,KAAK,CAAC;IACrI;EACF,CAAC;EACD,IAAM4D,cAAc,GAAGxE,wBAAwB,CAAC,YAAM;IACpDkE,cAAc,CAAC,CAAC;EAClB,CAAC,CAAC;EACF,IAAMO,kBAAkB,GAAGzE,wBAAwB,CAAC,YAAM;IACxD;IACA,IAAIgD,UAAU,IAAIjB,UAAU,EAAE;MAC5B,IAAMuB,UAAU,GAAGN,UAAU,CAAC,CAAC;MAC/B,IAAIM,UAAU,IAAIZ,kBAAkB,CAACU,OAAO,EAAE;QAC5C,IAAMS,UAAU,GAAGxD,aAAa,CAACiD,UAAU,CAAC;QAC5C,IAAME,eAAe,GAAGnD,aAAa,CAACqC,kBAAkB,CAACU,OAAO,CAAC;QACjE,IAAMU,QAAQ,GAAG1D,WAAW,CAACoD,eAAe,EAAEK,UAAU,EAAEZ,iBAAiB,CAAC;QAC5E,IAAMc,WAAW,GAAG5D,cAAc,CAACqD,eAAe,EAAEK,UAAU,EAAE3C,YAAY,CAAC;QAC7E,IAAI4C,QAAQ,KAAKZ,SAAS,IAAInB,UAAU,CAAC0B,GAAG,KAAKK,QAAQ,IAAIC,WAAW,KAAKb,SAAS,IAAInB,UAAU,CAACkC,MAAM,KAAKF,WAAW,EAAE;UAC3H;QACF;MACF;IACF;IACA;IACAG,cAAc,CAAC,CAAC;EAClB,CAAC,CAAC;EACF,IAAMQ,YAAY,GAAG,SAAfA,YAAYA,CAAA,EAAS;IACzB,IAAMC,cAAc,GAAG3B,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,UAAU,CAAC,CAAC;IAC3F1C,cAAc,CAACsE,OAAO,CAAC,UAAAC,SAAS,EAAI;MAClC,IAAI9D,EAAE;MACN,IAAI0B,YAAY,CAACW,OAAO,EAAE;QACxB,CAACrC,EAAE,GAAGyB,UAAU,CAACY,OAAO,MAAM,IAAI,IAAIrC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC+D,mBAAmB,CAACD,SAAS,EAAEpC,YAAY,CAACW,OAAO,CAAC;MACxH;MACAuB,cAAc,KAAK,IAAI,IAAIA,cAAc,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,cAAc,CAACI,gBAAgB,CAACF,SAAS,EAAEJ,kBAAkB,CAAC;IAChI,CAAC,CAAC;IACFjC,UAAU,CAACY,OAAO,GAAGuB,cAAc;IACnClC,YAAY,CAACW,OAAO,GAAGqB,kBAAkB;EAC3C,CAAC;EACD,IAAMO,eAAe,GAAG,SAAlBA,eAAeA,CAAA,EAAS;IAC5B,IAAIpC,KAAK,CAACQ,OAAO,EAAE;MACjB6B,YAAY,CAACrC,KAAK,CAACQ,OAAO,CAAC;MAC3BR,KAAK,CAACQ,OAAO,GAAG,IAAI;IACtB;IACA,IAAM8B,SAAS,GAAGlC,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,UAAU,CAAC,CAAC;IACtF1C,cAAc,CAACsE,OAAO,CAAC,UAAAC,SAAS,EAAI;MAClC,IAAI9D,EAAE;MACNmE,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACJ,mBAAmB,CAACD,SAAS,EAAEJ,kBAAkB,CAAC;MAClH,IAAIhC,YAAY,CAACW,OAAO,EAAE;QACxB,CAACrC,EAAE,GAAGyB,UAAU,CAACY,OAAO,MAAM,IAAI,IAAIrC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC+D,mBAAmB,CAACD,SAAS,EAAEpC,YAAY,CAACW,OAAO,CAAC;MACxH;IACF,CAAC,CAAC;IACFoB,cAAc,CAACW,MAAM,CAAC,CAAC;IACvBV,kBAAkB,CAACU,MAAM,CAAC,CAAC;EAC7B,CAAC;EACDvF,KAAK,CAACwF,mBAAmB,CAACvE,GAAG,EAAE;IAAA,OAAO;MACpC2D,cAAc,EAAdA;IACF,CAAC;EAAA,CAAC,CAAC;EACH;EACA5E,KAAK,CAACyF,SAAS,CAAC,YAAM;IACpB;IACA;IACAzC,KAAK,CAACQ,OAAO,GAAGkC,UAAU,CAACZ,YAAY,CAAC;IACxC,OAAO;MAAA,OAAMM,eAAe,CAAC,CAAC;IAAA;EAChC,CAAC,EAAE,EAAE,CAAC;EACNpF,KAAK,CAACyF,SAAS,CAAC,YAAM;IACpBX,YAAY,CAAC,CAAC;EAChB,CAAC,EAAE,CAACpD,MAAM,EAAES,UAAU,CAAC,CAAC;EACxBnC,KAAK,CAACyF,SAAS,CAAC,YAAM;IACpBb,cAAc,CAAC,CAAC;EAClB,CAAC,EAAE,CAAClD,MAAM,EAAEL,SAAS,EAAEC,YAAY,CAAC,CAAC;EACrC,IAAMqE,SAAS,GAAG1F,UAAU,EAAAiB,WAAA,OAAApB,eAAA,CAAAoB,WAAA,EACzBK,cAAc,EAAGY,UAAU,GAAArC,eAAA,CAAAoB,WAAA,EAC3BM,aAAa,EAAGW,UAAU,IAAIX,aAAa,GAAAN,WAAA,CAC7C,CAAC;EACF,IAAI0E,UAAU,GAAGzF,IAAI,CAACa,KAAK,EAAE,CAAC,WAAW,EAAE,WAAW,EAAE,cAAc,EAAE,QAAQ,EAAE,UAAU,EAAE,gBAAgB,EAAE,eAAe,CAAC,CAAC;EACjI,IAAIuD,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,MAAM,EAAE;IACnCmB,UAAU,GAAGzF,IAAI,CAACyF,UAAU,EAAE,CAAC,sBAAsB,CAAC,CAAC;EACzD;EACA,OAAO,aAAa5F,KAAK,CAAC6F,aAAa,CAAC3F,cAAc,EAAE;IACtD4F,QAAQ,EAAElB;EACZ,CAAC,EAAE,aAAa5E,KAAK,CAAC6F,aAAa,CAAC,KAAK,EAAEE,MAAM,CAACC,MAAM,CAAC;IACvD5E,KAAK,EAAEA,KAAK;IACZH,GAAG,EAAE6B;EACP,CAAC,EAAE8C,UAAU,CAAC,EAAEzD,UAAU,IAAI,aAAanC,KAAK,CAAC6F,aAAa,CAAC,KAAK,EAAE;IACpEzE,KAAK,EAAEmB,gBAAgB;IACvB,aAAa,EAAE;EACjB,CAAC,CAAC,EAAE,aAAavC,KAAK,CAAC6F,aAAa,CAAC,KAAK,EAAE;IAC1CF,SAAS,EAAEA,SAAS;IACpB1E,GAAG,EAAE8B,YAAY;IACjB3B,KAAK,EAAEe;EACT,CAAC,EAAE,aAAanC,KAAK,CAAC6F,aAAa,CAAC3F,cAAc,EAAE;IAClD4F,QAAQ,EAAElB;EACZ,CAAC,EAAEnD,QAAQ,CAAC,CAAC,CAAC,CAAC;AACjB,CAAC,CAAC;AACF,IAAMwE,KAAK,GAAG,aAAajG,KAAK,CAACe,UAAU,CAAC,UAACC,KAAK,EAAEC,GAAG,EAAK;EAC1D,IACaiF,kBAAkB,GAE3BlF,KAAK,CAFPmF,SAAS;IACT3E,aAAa,GACXR,KAAK,CADPQ,aAAa;EAEf,IAAA4E,kBAAA,GAEIpG,KAAK,CAACkD,UAAU,CAAC7C,aAAa,CAAC;IADjCgG,YAAY,GAAAD,kBAAA,CAAZC,YAAY;EAEd,IAAM9E,cAAc,GAAG8E,YAAY,CAAC,OAAO,EAAEH,kBAAkB,CAAC;EAChE,IAAAI,SAAA,GAA0BhG,QAAQ,CAACiB,cAAc,CAAC;IAAAgF,UAAA,GAAAxG,cAAA,CAAAuG,SAAA;IAA3CE,OAAO,GAAAD,UAAA;IAAEE,MAAM,GAAAF,UAAA;EACtB,IAAMG,UAAU,GAAGX,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEhF,KAAK,CAAC,EAAE;IACzDO,cAAc,EAAdA,cAAc;IACdC,aAAa,EAAEvB,UAAU,CAACuB,aAAa,EAAEiF,MAAM;EACjD,CAAC,CAAC;EACF,OAAOD,OAAO,EAAE,aAAaxG,KAAK,CAAC6F,aAAa,CAAC/E,aAAa,EAAEiF,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEU,UAAU,EAAE;IAC5FzF,GAAG,EAAEA;EACP,CAAC,CAAC,CAAC,CAAC;AACN,CAAC,CAAC;AACF,IAAIsD,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;EACzCwB,KAAK,CAACU,WAAW,GAAG,OAAO;AAC7B;AACA,eAAeV,KAAK"},"metadata":{},"sourceType":"module","externalDependencies":[]}